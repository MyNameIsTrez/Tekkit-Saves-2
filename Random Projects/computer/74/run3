local queue = {}
local callbacks = {}


function listen(event, callback_fn)
  if callbacks[event] == nil then
    callbacks[event] = {}
  end
  
  local callback_coro = coroutine.create(callback_fn)
  
  table.insert(callbacks[event], callback_coro)
end

local function runner()
  while true do
    --print("queue[1]: ", queue[1] ~= nil)
    
    if queue[1] then
      local eventData = table.remove(queue, 1)
      local event = eventData[1]
      print("event: ", event)
      if callbacks[event] then
        print("#callbacks[event]: ", #callbacks[event])
        for i = 1, #callbacks[event] do
          -- TODO: USE TABLE.UNPACK()!!
          --print("coroutine.resume()")
          coroutine.resume(callbacks[event][i], unpack(eventData))
        end
      end
    end
    
    coroutine.yield()
  end
end

local function queueHandler()
  while true do
    --print("starting os.pullEvent()")
    -- TODO: USE TABLE.PACK()!!!
    table.insert(queue, { os.pullEvent() })
    --print("inserted os.pullEvent(): ", queue[#queue][1])
  end
end


listen("key", function()
  print("key callback fired")
end)

listen("char", function()
  print("char callback fired")
end)

parallel.waitForAny(queueHandler, runner)
