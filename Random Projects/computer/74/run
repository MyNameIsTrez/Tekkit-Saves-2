local queue = {}
local callbacks = {}


function listen(event, callback_fn)
  if callbacks[event] == nil then
    callbacks[event] = {}
  end
  
  local callback_coro = coroutine.create(callback_fn)
  
  table.insert(callbacks[event], callback_coro)
end

local function runner()
  while true do
    print("queue[1]: ", queue[1] ~= nil)
    
    if queue[1] then
      local eventData = table.remove(queue, 1)
      local event = eventData[1]
      
      if callbacks[event] then
        for i = 1, #callbacks[event] do
          coroutine.resume(callbacks[event][i], unpack(eventData))
        end
      end
    end
    
    coroutine.yield()
  end
end

local function queueHandler()
  while true do
    print("starting os.pullEvent()")
    table.insert(queue, { os.pullEvent() })
    print("inserted os.pullEvent()")
  end
end


listen("key", function()
  print("callback_fn fired")
end)

parallel.waitForAny(runner, queueHandler)
